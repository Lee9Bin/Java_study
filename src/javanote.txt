*객체
정의: 의사나 행위가 미치는 대상(사전적 의미)
     구체적, 추상적 데이터의 단위(학생, 회원, 생산, 주문)

-객체 지향 프로그램 구현
1. 객체를 정의
2. 제공하는 기능들을 구현
3. 객체들의 기능들 간의 소통을 통하여 객체간 협력 구현

ex) class 학생{
    속성이 멤버변수로 선언된다.
    int studentId;
    String studentName;

    기능은 함수로 구현
    접근제어자 반환타입 함수이름(매개변수){
    지역변수(함수내에서만 사용하는 변수, 함수가 종료되면 자동으로 반환되는 변수)
    }
}


*생성자
-일반 함수처럼 기능을 호출하는 것이 아니고 객체를 생성하기 위해 new와 함께 호출
 객체가 생성될 때 변수나 상수를 초기화 하거나 다른 초기화 기능을 수행하는 메서드를 호출
    클래스 참조변수 = new 클래스
new키워드에 의해 객체(클래스 인스턴스가 힙메모리에 생성이 되고)가 생성 참조변수에는 인스턴스 값을 가르키는 메모리 주소값이 담김
즉 참조변수는 인스턴스를 가르키는 리모컨이고 인스턴스는 실제 값이라 생각해보자

-기본생성자
클래스 내부에 생성자가 하나도!!! 없다면 컴파일러가 생성자 코드를 넣어줌
그래서 이때는 구현하지 않아도 생성자 호출 가능

-생성자 오버로딩
생성자를 두개 이상 구현하는 경우
따라서
클래스(매개변수){
} ---->구현을 하면 컴파일러는 기본 생성자를 넣어주지 않기 때문에
클래스(){} 기본생성자를 사용할거면 선언해야해


*접근제어자
클래스 외부에서 클래스의 멤버 변수, 메서드, 생성자를 사용할 수 있는지 여부를 지정하는 키워드

-private : 같은 클래스 내부에서만 접근 가능 ( 외부 클래스, 상속 관계의 클래스에서도 접근 불가)
           멤버 변수에 대해 접근 수정할 수 있게 get(), set()메서드를 사용
           그렇다면 get()만 쓰면 읽기만 가능하게 하지
           이를통해 정보 은닉을 하고 최소한의 정보를 오픈함으로써 객체의 오류를 방지
-아무것도 없음 (default) : 같은 패키지 내부에서만 접근 가능 ( 상속 관계라도 패키지가 다르면 접근 불가)
-protected : 같은 패키지나 상속관계의 클래스에서 접근 가능하고 그 외 외부에서는 접근 할 수 없음
-public : 클래스의 외부 어디서나 접근 할 수 있음


*this
-인스턴스 자신의 메모리를 가르킨다.
-생성자에서 또 다른 생성자를 호출 할때 사용
ex)public Person() {
   		this("이름없음", 1);
   	}

   	public Person(String name, int age) {
   		this.name = name;
   		this.age = age;
   	}
-자신의 주소값을 반환


*static 변수
데이터 영역 메모리
인스턴스가 생성될 때 만들어지는 변수가 아닌, 처음 프로그램이 메모리에 로딩될 때 메모리를 할당
(따라서 클래스 이름으로 호출 가능)
여러 인스턴스가 공유하는 기준 값이 필요한 경우
ex)학생마다 새로운 학번을 만들어야 하는 경우


*클래스 상속
새로운 클래스를 정의 할 때 이미 구현된 클래스를 상속 받아서 속성이나 기능을 확장해서 구현
이미 구현된 클래스보다 더 구체적인 기능을 가진 클래스를 구현해야 할때 상속

-상속의 문법
    하위        상위
class B extends A{
}

-하위 클래스가 생성 되는 과정
하위 클래스를 생성하면 상위 클래스가 먼저 생성 됨
클래스가 상속 받은 경우 하위 클래스의 생성자에서는 반드시 상위 클래스의 생성자를 호출 한다.
어떻게?? super 키워드를 통해

-super
하위 클래스에서 가지는 상위 클래스에 대한 참조 값
super()는 상위 클래스의 기본 생성자를 호출 함
하위 클래스에서 명시적으로 상위 클래스의 생성자를 호출하지 않으면 super()가 호출 된다. ( 이때 반드시 상위 클래스의 기본 생성자가 존재 해야 함)
상위 클래스의 기본 생성자가 없는 경우 ( 다른 생성자가 있는 경우 ) 하위 클래스에서는 생성자에서는 super를 이용하여 명시적으로 상위 클래스의 생성자를 호출 함
super는 생성된 상위 클래스 인스턴스의 참조 값을 가지므로 super를 이용하여 상위 클래스의 메서드나 멤버 변수에 접근할 수 있음

-상속에서 인스턴스 메모리의 상태
항상 상위 클래스의 인스턴스가 먼저 생성되고, 하위 클래스의 인스턴스가 생성된다.

-형변환(업캐스팅)
상위 클래스로 변수를 선언하고 하위 클래스의 생성자로 인스턴스를 생성 가능
Customer customerLee = new VIPCustomer();
상위 클래스 타입의 변수에 하위 클래스 변수가 대입 가능
VIPCustomer vCustomer = new VIPCustomer();
addCustomer(vCustomer);
int addCustomer(Customer customer){
}
why? 항상 상위 클래스의 인스턴스가 먼저 생성되고, 하위 클래스의 인스턴스가 생성된다.
하위 클래스는 상위 클래스의 타입을 내포하고 있으므로 상위 클래스로의 묵시적 형 변환이 가능하다.
상속 관계에서 모든 하위 클래스는 상위 클래스로 형 변환(업캐스팅)이 된다.
(그 역은 성립하지 않음)

주의!!
VIPCustomer() 생성자에 의해 VIPCustomer 클래스의 모든 멤버 변수에 대한 메모리는 생성되었지만,
변수의 타입이 Customer 이므로 실제 접근 가능한 변수나 메서드는 Customer의 변수와 메서드임

-하위 클래스에서 메서드 재정의하기(오버라이딩)
상위클래스에 정의된 메서드의 구현 내용이 하위 클래스에서 구현할 내용과 맞지 않는 경우
하위 클래스에서 동일한 이름!!!의 메서드를 재정의 할 수 있다.


* @overriding 애노테이션
애노테이션은 원래 주석이라는 의미
컴파일러에게 특별한 정보를 제공해주는 역할
@Overrid : 재정의된 메서드라는 정보 제공
@FunctionalInterface: 함수형 인터페이스라는 정보 제공
@Deprecated: 이후 버전에서 사용되지 않을 수 있는 변수, 메서드에 사용된다.
@SupperssWarnings: 특정 경고가 나타나지 않도록한다.

